
  <!DOCTYPE html>
  <html lang="en">

  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
<meta name="theme-color" content="#181819" media="(prefers-color-scheme: dark)" />
<base href="/" />

    <link rel="stylesheet" href="styles/main.css" />
    <link rel="stylesheet" href="styles/note.css" />
    <link rel="stylesheet" href="styles/code.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Public+Sans&display=swap" rel="stylesheet">
    <title>Write a header-only object oriented interface around MPI</title>
    <meta name="title" content="Write a header-only object oriented interface around MPI" />
    <meta name="description" content="Write interface around MPI." />
    <meta name="keywords" content="C++, MPI" />
    <meta property="og:title" content="Write a header-only object oriented interface around MPI" />
    <meta property="og:description" content="Write interface around MPI." />
    <meta property="og:url" content="https://kennethassogba.github.ionotes/write-interface-mpi" />
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="assets/meta/favicon-180.png" />
<link rel="apple-touch-icon" sizes="180x180" href="assets/meta/favicon-180.png" />
<link rel="icon" type="image/png" sizes="192x192" href="assets/meta/favicon-192.png" />
<link rel="icon" type="image/png" sizes="32x32" href="assets/meta/favicon-32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="assets/meta/favicon-16.png" />
    <meta property="og:type" content="website" />
<meta property="og:image" content="https://kennethassogba.github.io/assets/img/me.jpg" />
<meta property="og:image:width" content="2400" />
<meta property="og:image:height" content="1200" />
<meta name="twitter:card" content="summary" />
    <script type="application/ld+json">
        {
          "@context": "https://schema.org/",
          "@type": "Article",
          "headline": "Write a header-only object oriented interface around MPI",
          "description": "Write interface around MPI.",
          "datePublished": "2023-04-07",
          "author": {
            "@type": "Person",
            "name": "Kenneth Assogba",
            "url": "https://kennethassogba.github.io"
          },
          "image": {
            "@type": "ImageObject",
            "url": "https://kennethassogba.github.io/assets/meta/open-graph-card.jpg",
            "width": 2400,
            "height": 1200
          }
        }
      </script>
  </head>

  <body>
    <main>
      <h1>Write a header-only object oriented interface around MPI</h1>
      <time datetime="2023-04-07">2023-04-07</time>
      <p>(in progress)</p>
<p><strong><code>tl;dr: I developed a simple header-only interface for MPI in C++.</code></strong></p>
<p>The developments are availible here <a href="https://github.com/kennethassogba/human.mpi">human.mpi</a></p>
<p>MPI, or Message Passing Interface, is a standardized library for writing parallel programs in a distributed environment. It has become a standard in scientific computing and many legacy computing codes are progressively integrating MPI in view of the move to distributed computing architectures.</p>
<h2 id="problem">Problem</h2>
<p>The addition of MPI communications within an existing computational code can lead to difficulties in readability and maintainability. This is partly because the physics (or math) + communications code mix is difficult to read. A good way to integrate MPI into existing code can be to encapsulate the MPI functions in a class with a simple interface. This is what Boost::MPI offers, for example.</p>
<h2 id="proposal">Proposal</h2>
<p>I propose here a header-only interface - so easy to integrate in an existing code - which provides a simpler way to write MPI messages.</p>
<p>The development of an object-oriented interface for MPI could potentially make it easier for developers to write parallel programs using MPI, as the wrapper could handle some of the more complex details of the library.</p>
<p>In addition this could also potentially make it easier to port existing MPI programs to different platforms or environments, as the wrapper would provide a consistent interface that is independent of the underlying implementation of MPI.</p>
<h2 id="a-simple-usage-example">A simple usage example</h2>
<pre class="language-cpp"><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;human/mpi.hpp&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{

 human::<span class="hljs-function">mpi::communicator <span class="hljs-title">world</span><span class="hljs-params">()</span></span>;
 <span class="hljs-keyword">auto</span> rank = world.<span class="hljs-built_in">rank</span>();
 <span class="hljs-keyword">auto</span> size = world.<span class="hljs-built_in">size</span>();
 std::cout &lt;&lt; <span class="hljs-string">&quot;Process &quot;</span> &lt;&lt; rank &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; size &lt;&lt; std::endl;
 
 std::string msg;
 <span class="hljs-keyword">if</span> (world.<span class="hljs-built_in">rank</span>() == world.<span class="hljs-built_in">root</span>()) msg = <span class="hljs-string">&quot;Hello&quot;</span>;
 
 world.<span class="hljs-built_in">bcast</span>(msg);
 std::cout &lt;&lt; <span class="hljs-string">&quot;P&quot;</span> &lt;&lt; rank &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;
 
 world.<span class="hljs-built_in">display</span>();
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre><p>To use this wrapper, you would first need to include the header file that contains the wrapper class. Then, you can create an instance of the wrapper class by passing the <strong><code>argc</code></strong> and <strong><code>argv</code></strong> arguments from the <strong><code>main</code></strong> function to the constructor. This will initialize the MPI library and allow you to use the wrapper&#39;s <strong><code>Send</code></strong> and <strong><code>Receive</code></strong> methods to communicate with other processes. When the wrapper instance goes out of scope (e.g., at the end of the <strong><code>main</code></strong> function), the destructor will be called, which will finalize the MPI library.</p>
<p>Here is an example of how to use the wrapper to</p>
<p>In progress</p>

      <hr />
      <p class="thanks">Thanks for reading! Go <a href="notes.html">back</a> for more notes.</p>
    </main>
  </body>

  </html>
